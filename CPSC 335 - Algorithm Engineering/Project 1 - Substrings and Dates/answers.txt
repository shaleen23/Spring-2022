///////////////////////////////////////////////////////////////////////////////
// algorithms.hpp
//
// Definitions for four algorithms:
//
// run_length_encode
// longest_frequent_substring
// reformat_date
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <algorithm>
#include <iostream>
#include <map>
#include <string.h>
#include <string>

namespace algorithms {

// Run-length-encode the given string.
//
// uncompressed must be a string containing only lower-case letters or spaces.
//
// A run is defined as a sequence of K>2 contiguous copies of the same
// character c.
// For example, "aaa" is a run with K=3 and c='a'.
// This function returns a string based on uncompressed, where every run is
// replaced with the string
//   COUNTc
// where COUNT is the base-10 representation of K. Non-run characters are
// left as-is.
//
// Example inputs and outputs:
//   "aaa" -> "3a"
//   "heloooooooo there" -> "hel8o there"
//   "footloose and fancy free" -> "f2otl2ose and fancy fr2e"
//
// Throws std::invalid_argument if the string contains invalid characters.

std::string append_run(std::string C, char run_char, int run_length) {
  if (run_length > 1)
    C += std::to_string(run_length);
  C += run_char;

  return C;
}

std::string run_length_encode(const std::string &uncompressed) {
  std::string C = "";

  if (uncompressed.empty())
    return C;

  char run_char = uncompressed[0];
  int run_length = 1;

  for (int i = 1; i < uncompressed.length(); i++) {
    if (isspace(uncompressed[i]) && isspace(uncompressed[i + 1]))
      throw std::invalid_argument("Invalid character.");
    else if (uncompressed[i] == run_char)
      run_length++;
    else {
      C = append_run(C, run_char, run_length);
      run_char = uncompressed[i];
      run_length = 1;
    }
  }

  C = append_run(C, run_char, run_length);
  return C;
}

// Returns the longest substring of text, such that every character in the
// substring appears at least k times in text.
// If there are ties, the substring that appears first is returned.

std::string longest_frequent_substring(const std::string &text, unsigned k) {
  std::map<char, int> Dictionary;
  char holder;

  for (int i = 0; i < text.size(); i++) {
    holder = text[i];
    if (Dictionary.find(holder) == Dictionary.end()) {
      Dictionary[holder] = 1;
    } else {
      Dictionary[holder]++;
    }
  }

  std::string best = "";
  std::string cand = "";
  int iterator = 1;
  bool abovek = 1;

  for (int m = 0; m < text.size(); m++) {
    iterator = 1;
    for (int n = m + 1; n <= text.size(); n++) {
      cand = text.substr(m, iterator);
      iterator++;
      for (int x = 0; x < cand.size(); x++) {
        holder = cand[x];
        if ((Dictionary[holder]) < k) {
          abovek = 0;
          break;
        }
      }
      if (abovek == 1) {
        if (cand.size() > best.size()) {
          best = cand;
        }
      }
      abovek = 1;
    }
  }
  return best;
}

// Reformats a string containing a date into YYYY-MM-DD format.
//
// input may be formatted in one of four patterns:
// 1. Y-M-D
//    where Y, M, and D are positive integers
// 2. M/D/Y
//    where Y, M, and D are positive integers
// 3. MONTH DAY, YEAR
//    where
//    - MONTH is a case-insensitive name of a month, ex.
//      "january", "FEBRUARY", "March", etc.
//    - DAY is a positive integer representing a day, e.x. "15"
//    - YEAR is a positive integer representing a year, e.x. "2022"
// 4. MON DAY, YEAR
//    where
//    - MON is a case-insensitive three-letter abbreviation of a month, ex.
//      "jan", "FEB", "Mar", etc.
//    - DAY is the same as above
//    - YEAR is the same as above
//
// Any leading spaces or trailing spaces are ignored.
//
// Returns a string in strict YYYY-MM-DD format.
//
// Throws std::invalid argument if:
// - input does not fit any of the four patterns
// - MONTH is not a valid month name
// - MON is not a valid month abbreviation
// - DAY is not in the range [1, 31]
// - YEAR is not in the range [1900, 2099]

std::string reformat_date(const std::string &input) {

  std::string output;
  // want YYYY-MM-DD

  std::string mon[] = {"jan", "feb", "mar", "apr", "may", "jun",
                       "jul", "aug", "sep", "oct", "nov", "dec"};
  std::string months[] = {"january",   "february", "march",    "april",
                          "may",       "june",     "july",     "august",
                          "september", "october",  "november", "december"};

  // 1 means - format, 2 means / format, 3 mean MON format, 4 means MONTH format
  int stage = 4;

  std::string day, month, year;
  int iday, imonth = 0, iyear;

  for (int s = 0; s < input.size(); s++) {
    if (isdigit(input[s])) {
      break;
    }
    if (s == input.size() - 1) {
      throw std::invalid_argument("Invalid character.");
    }
  }

  std::string cleanInput = "";
  char c;
  int i = 0;

  while (input[i]) {
    c = input[i];
    cleanInput += std::tolower(c);
    i++;
  }

  // this for loop helps find the format
  for (int i = 0; i < cleanInput.size(); i++) {
    if (cleanInput[i] == '-') {
      stage = 1;
    }
    if (cleanInput[i] == '/') {
      stage = 2;
    }
    if (cleanInput[3] == ' ' && isalpha(cleanInput[0])) {
      stage = 3;
    }
  }

  if (stage == 1) {
    int a = 0;
    do {
      year += cleanInput[a++];
    } while (cleanInput[a] != '-');
    a++;

    do {
      month += cleanInput[a++];
    } while (cleanInput[a] != '-');
    a++;
    if (month.size() == 1) {
      month = '0' + month;
    }

    do {
      day += cleanInput[a++];
      if (isalpha(cleanInput[a]) || cleanInput[a] == '-') {
        throw std::invalid_argument("Invalid character.");
      }
    } while (input[a]);
    if (day.size() == 1) {
      day = '0' + day;
    }
    day.erase(remove(day.begin(), day.end(), ' '), day.end());
    year.erase(remove(year.begin(), year.end(), ' '), year.end());

    iday = stoi(day);
    imonth = stoi(month);
    iyear = stoi(year);

    if ((iday >= 1 && iday <= 31) && (imonth >= 1 && imonth <= 12) &&
        (iyear >= 1900 && iyear <= 2099)) {
      output = year + '-' + month + '-' + day;
    } else {
      throw std::invalid_argument("Invalid character.");
    }
  }

  if (stage == 2) {
    int a = 0;
    do {
      month += cleanInput[a++];
    } while (cleanInput[a] != '/');
    a++;
    if (month.size() == 1) {
      month = '0' + month;
    }

    do {
      day += cleanInput[a++];
    } while (cleanInput[a] != '/');
    a++;
    if (day.size() == 1) {
      day = '0' + day;
    }
    do {
      year += cleanInput[a++];
      if (isalpha(cleanInput[a])) {
        throw std::invalid_argument("Invalid character.");
      }
    } while (cleanInput[a]);

    iday = stoi(day);
    imonth = stoi(month);
    iyear = stoi(year);

    if ((iday >= 1 && iday <= 31) && (imonth >= 1 && imonth <= 12) &&
        (iyear >= 1900 && iyear <= 2099)) {
      output = year + '-' + month + '-' + day;
    } else {
      throw std::invalid_argument("Invalid character.");
    }
  }

  if (stage == 3) {
    int a = 0;

    do {
      month += cleanInput[a++];
    } while (cleanInput[a] != ' ');
    a++;

    do {
      day += cleanInput[a++];
    } while (cleanInput[a] != ',');
    a++;
    a++;
    if (day.size() == 1) {
      day = '0' + day;
    }

    do {
      year += cleanInput[a++];
      if (isalpha(cleanInput[a])) {
        throw std::invalid_argument("Invalid character.");
      }
    } while (cleanInput[a]);

    iday = stoi(day);
    iyear = stoi(year);

    for (int x = 0; x < month.length(); x++) {
      if (month[x] >= 'A' && month[x] <= 'Z') {
        month[x] = ((char)(month[x] - 'A' + 'a'));
      }
    }

    for (int b = 0; b < 12; b++) {
      if (month == mon[b]) {
        imonth = b + 1;
      }
    }
    month = std::to_string(imonth);
    if (month.size() == 1) {
      month = '0' + month;
    }

    if ((iday >= 1 && iday <= 31) && (imonth >= 1 && imonth <= 12) &&
        (iyear >= 1900 && iyear <= 2099)) {
      output = year + '-' + month + '-' + day;
    } else {
      throw std::invalid_argument("Invalid character.");
    }
  }

  if (stage == 4) {
    int a = 0;

    do {
      month += cleanInput[a++];
    } while (cleanInput[a] != ' ');
    a++;

    do {
      day += cleanInput[a++];
    } while (cleanInput[a] != ',');
    a++;
    a++;
    if (day.size() == 1) {
      day = '0' + day;
    }

    do {
      year += cleanInput[a++];
    } while (cleanInput[a]);

    if (year.size() > 4) {
      throw std::invalid_argument("Invalid character.");
    }

    iday = stoi(day);
    iyear = stoi(year);

    for (int x = 0; x < month.length(); x++) {
      if (month[x] >= 'A' && month[x] <= 'Z') {
        month[x] = ((char)(month[x] - 'A' + 'a'));
      }
    }

    for (int b = 0; b <= 12; b++) {
      if (month == months[b]) {
        imonth = b + 1;
      }
    }

    if (imonth == 0) {
      throw std::invalid_argument("Invalid character.");
    }

    month = std::to_string(imonth);
    if (month.size() == 1) {
      month = '0' + month;
    }

    if ((iday >= 1 && iday <= 31) && (imonth >= 1 && imonth <= 12) &&
        (iyear >= 1900 && iyear <= 2099)) {
      output = year + '-' + month + '-' + day;
    } else {
      throw std::invalid_argument("Invalid character.");
    }
  }

  return output;		
}

} // namespace algorithms